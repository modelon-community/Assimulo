!    -*- f90 -*-
! Note: the context of this file is case sensitive.

python module radcor__user__routines 
    interface radcor_user_interface 

        subroutine fcn(n,t,y,yp,arglag,phi,rpar,ipar,past,ipast,nrds) ! in :radar5:radar5.f90:radcor:unknown_interface
            integer, optional,check(len(y)>=n),depend(y),intent(hide) :: n=len(y)
            double precision :: t
            real(kind=8) dimension(n),intent(in) :: y
            real(kind=8), allocatable,dimension(n),intent(out) :: yp
            intent(callback), external arglag
            intent(callback), external phi
            real(kind=8) dimension(1),intent(hide) :: rpar
            integer dimension(1),intent(hide) :: ipar
            real(kind=8), dimension(*), intent(in) :: past
            integer dimension(nrds),intent(in) :: ipast
            integer, optional,check(len(ipast)>=nrds),depend(ipast),intent(hide) :: nrds=len(ipast)
        end subroutine fcn

        subroutine jac(n,t,y,fjac,ldjac,arglag,phi,rpar,ipar,past,ipast,nrds) ! in :radar5:radar5.f90:radcor:unknown_interface
            integer, optional,check(len(y)>=n),depend(y),intent(hide) :: n=len(y)
            double precision, intent(in) :: t
            real(kind=8) dimension(n),intent(in) :: y
            real(kind=8), allocatable,dimension(n,n),depend(n), intent(out) :: fjac
            integer, depend(n), intent(hide) :: ldjac = n # Leading dimension of jacobian
            intent(callback), external arglag
            intent(callback), external phi
            real(kind=8) dimension(1),intent(hide) :: rpar
            integer dimension(1),intent(hide) :: ipar
            real(kind=8), dimension(*), intent(in) :: past
            integer dimension(nrds),intent(in) :: ipast
            integer, optional,check(len(ipast)>=nrds),depend(ipast),intent(hide) :: nrds=len(ipast)
        end subroutine jac


        function arglag(i,t,y,rpar,ipar,phi,past,ipast,nrds) ! in :radar5:radar5.f90:radcor:unknown_interface
            integer, intent(in) :: i
            double precision, intent(in) :: t
            real(kind=8), allocatable,dimension(*) :: y
            real(kind=8) dimension(1),intent(hide) :: rpar
            integer dimension(1),intent(hide) :: ipar
            intent(callback), external phi
            real(kind=8), dimension(*), intent(in) :: past
            integer dimension(nrds),intent(in) :: ipast
            integer, optional,check(len(ipast)>=nrds),depend(ipast),intent(hide) :: nrds=len(ipast)
            real*8 :: arglag
        end function arglag

        subroutine solout(nrsol,told,t,hsol,y,cont,lrc,n,rpar,ipar,interrupt) ! in :radar5:radar5.f90:radcor:unknown_interface
            integer, intent(hide) :: nrsol
            double precision, intent(in) :: told
            double precision, intent(in) :: t
            double precision, intent(in) :: hsol # Current step size
            real(kind=8) dimension(n),intent(in) :: y
            real(kind=8), allocatable,dimension(lrc), intent(in) :: cont
            integer, intent(in, hide) :: lrc
            integer, intent(in, hide) :: n
            real(kind=8) dimension(1),intent(hide) :: rpar
            integer dimension(1),intent(hide) :: ipar
            integer, intent(out) :: interrupt  # Interrupt the integration if < 0
        end subroutine solout



        subroutine jaclag(n,t,y,fjaclag,arglag,phi,ive,ivc,ivl,rpar,ipar,past,ipast,nrds) ! in :radar5:radar5.f90:radcor:unknown_interface
            integer, intent(hide) :: n
            double precision :: t
            real(kind=8) dimension(n),intent(in) :: y
            real(kind=8), allocatable,dimension(:), intent(out) :: fjaclag # Array of derivatives of fcn for the combinations given in ive, ivc, ivl
            intent(callback), external arglag
            intent(callback), external phi
            integer, allocatable,dimension(:), intent(out) :: ive	# Which equations
            integer, allocatable,dimension(:), intent(out) :: ivc	# Which components
            integer, allocatable,dimension(:), intent(out) :: ivl	# Which delays
            real(kind=8) dimension(1),intent(hide) :: rpar
            integer dimension(1),intent(hide) :: ipar
            real(kind=8), dimension(*), intent(in) :: past
            integer dimension(nrds),intent(in) :: ipast
            integer, optional,check(len(ipast)>=nrds),depend(ipast),intent(hide) :: nrds=len(ipast)
        end subroutine jaclag

        function phi(i,t,rpar,ipar) ! in :radar5:radar5.f90:radcor:unknown_interface
            integer, intent(in) :: i
            real*8, intent(in) :: t
            real(kind=8) dimension(1), intent(hide) :: rpar
            integer, intent(hide) :: ipar
            real*8 :: phi
        end function phi

		subroutine mas(n,am,lmas,rpar,ipar) ! in :radar5:radar5.f90:radcor:unknown_interface
            integer, intent(in, hide) :: n
            double precision dimension(lmas,n),depend(lmas,n),intent(in,out) :: am
            !double precision dimension(n),depend(n),intent(hide) :: lmas
            integer, optional,intent(hide) :: lmas=1
            double precision dimension(1),intent(hide) :: rpar
            integer dimension(1),intent(hide) :: ipar
        end subroutine mas

    end interface radcor_user_interface
end python module radcor__user__routines



python module radar5 ! in 
    interface  ! in :radar5
        module ip_array ! in :radar5:radar5.f90
            integer dimension(100) :: iposv
        end module ip_array

        subroutine radar5(n,fcn,phi,arglag,t,y,tend,h,rtol,atol,itol,jac,ijac,mljac,mujac,jaclag,nlags,njacl,imas,solout,iout,work,iwork,rpar,ipar,idid,grid,ipast,mas,mlmas,mumas) ! in :radar5:radar5.f90
            use ip_array
            use radcor__user__routines
            integer, optional,check(len(y)>=n),depend(y),intent(hide) :: n=len(y)      
            external fcn
            external phi
            external arglag
            double precision, intent(in,out) :: t
            real(kind=8) dimension(n),intent(in,out) :: y
            double precision, intent(in) :: tend
            double precision, intent(in, out) :: h
            real(kind=8) dimension(n), intent(in) :: rtol
            real(kind=8) dimension(n), intent(in) :: atol
            integer, intent(in) :: itol # 0: rtol/atol are scalars. 1: rtol/atol are vectors.
            external jac
            integer, intent(in) :: ijac  # 0: finite-difference jac. 1: use jac-function
            integer, intent(in) :: mljac # Lower bandwidth of jacobian
            integer, intent(in) :: mujac # Upper bandwidth of jacobian
            external jaclag
            integer, intent(in) :: nlags	# Number of delay arguments to differentiate for
            integer, intent(in) :: njacl	# Number of possible delay arguments that fcn can be differentiated with respect to
            integer, intent(in) :: imas		# 0: Mass matrix = identity. 1: Use mass matrix given in mas
            external solout
            integer, intent(in) :: iout		# 0: Never call solout. 1. Call solout after every step.
            real(kind=8) dimension(*),intent(in) :: work	# State parameters
            integer dimension(*),intent(in,out) :: iwork		# State parameters (integers)
            real(kind=8) dimension(1),intent(hide) :: rpar
            integer dimension(1),intent(hide) :: ipar
            integer, intent(out) :: idid					# Integration success report
            real(kind=8) dimension(*),intent(in) :: grid	# Integration must stop at these grid points (size > IWORK(13)+1)
            integer dimension(*),intent(in) :: ipast		# Which components require dense output (size IWORK(15))
            external mas
            integer, intent(in) :: mlmas	# Lower bandwidth of mass matrix
            integer, intent(in) :: mumas	# Upper bandwidth of mass matrix
            double precision :: x0b
            double precision :: uround
            double precision :: hmax
            integer :: iact
            integer :: irtrn
            integer :: idif
            integer :: mxst
            logical :: flags
            logical :: flagn
            common /posits/ x0b,uround,hmax,iact,irtrn,idif,mxst,flags,flagn
        end subroutine radar5

        subroutine lagr5(i,t,y,arglag,past,theta,ipos,rpar,ipar,phi,ipast,nrds) ! in :radar5:radar5.f90
            use ip_array
            use radcor__user__routines
            integer :: i
            double precision :: t
            real(kind=8) dimension(*),intent(in) :: y
            external arglag
            #real(kind=8), allocatable,dimension(:), intent(in) :: past
            real(kind=8) dimension(*),intent(in) :: past
            double precision, intent(out) :: theta
            integer, intent(out) :: ipos
            real(kind=8) dimension(1),intent(hide) :: rpar
            integer dimension(1),intent(hide) :: ipar
            external phi
            integer dimension(nrds),intent(in) :: ipast
            integer, optional,check(len(ipast)>=nrds),depend(ipast),intent(hide) :: nrds=len(ipast)
            double precision :: x0b
            double precision :: uround
            double precision :: hmax
            integer :: iact
            integer :: irtrn
            integer :: idif
            integer :: mxst
            logical :: flags
            logical :: flagn
            double precision :: bpp
            integer :: ilbp
            logical :: left
            logical :: first
            logical :: last
            logical :: reject
            logical :: bpd
            common /posits/ x0b,uround,hmax,iact,irtrn,idif,mxst,flags,flagn
            common /bpcom/ bpp,ilbp,left
            common /bplog/ first,last,reject,bpd
        end subroutine lagr5

        function ylagr5(i,theta,ipos,phi,rpar,ipar,past,ipast,nrds) ! in :radar5:radar5.f90
            use radcor__user__routines
            integer :: i
            double precision :: theta
            integer :: ipos
            external phi
            real(kind=8) dimension(1),intent(hide) :: rpar
            integer dimension(1),intent(hide) :: ipar
            real(kind=8) dimension(*),intent(in) :: past
            integer dimension(nrds),intent(in) :: ipast
            integer, optional,check(len(ipast)>=nrds),depend(ipast),intent(hide) :: nrds=len(ipast)
            double precision :: x0b
            double precision :: uround
            double precision :: hmax
            integer :: iact
            integer :: irtrn
            integer :: idif
            integer :: mxst
            logical :: flags
            logical :: flagn
            double precision :: c1
            double precision :: c2
            double precision :: c1m1
            double precision :: c2m1
            double precision :: c1mc2
            double precision :: ylagr5
            common /posits/ x0b,uround,hmax,iact,irtrn,idif,mxst,flags,flagn
            common /constn/ c1,c2,c1m1,c2m1,c1mc2
        end function ylagr5

        function dlagr5(i,theta,ipos,phi,rpar,ipar,past,ipast,nrds) ! in :radar5:radar5.f90
            use radcor__user__routines
            integer :: i
            double precision :: theta
            integer :: ipos
            external phi
            real(kind=8) dimension(1),intent(hide) :: rpar
            integer dimension(1),intent(hide) :: ipar
            real(kind=8) dimension(*),intent(in) :: past
            integer dimension(nrds),intent(in) :: ipast
            integer, optional,check(len(ipast)>=nrds),depend(ipast),intent(hide) :: nrds=len(ipast)
            double precision :: x0b
            double precision :: uround
            double precision :: hmax
            integer :: iact
            integer :: irtrn
            integer :: idif
            integer :: mxst
            logical :: flags
            logical :: flagn
            double precision :: c1
            double precision :: c2
            double precision :: c1m1
            double precision :: c2m1
            double precision :: c1mc2
            double precision :: dlagr5
            common /posits/ x0b,uround,hmax,iact,irtrn,idif,mxst,flags,flagn
            common /constn/ c1,c2,c1m1,c2m1,c1mc2
        end function dlagr5

        function contr5(i,n,t,cont,xsol,hsol) ! in :radar5:radar5.f90
            integer :: i
            integer :: n
            double precision :: t
            real(kind=8) dimension(*),intent(in) :: cont
            double precision :: xsol
            double precision :: hsol
            double precision :: c1
            double precision :: c2
            double precision :: c1m1
            double precision :: c2m1
            double precision :: c1mc2
            double precision :: contr5
            common /constn/ c1,c2,c1m1,c2m1,c1mc2
        end function contr5


    end interface 
end python module radar5

! This file was auto-generated with f2py (version:2).
! See http://cens.ioc.ee/projects/f2py2e/
