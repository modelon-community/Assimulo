--- C:/Development/Assimulo/branches/Assimulo-Delay-201202/thirdparty/hairer/radar5.f90	ti jun 26 13:37:26 2012
+++ C:/Development/Assimulo/branches/Assimulo-Delay-201202/thirdparty/hairer/radar5.f	on jul 20 15:26:52 2005
@@ -43,7 +43,7 @@
 C        ALLOWED DELAYS; IF A LARGER NUMBER OF RETARDED ARGUMENT IS  
 C        REQUIRED CHANGE THE DIMENSION TO THE DESIRED VALUE AND RECOMPILE 
 C        HERE THE DIMENSION IS SET TO 100 
-         INTEGER, dimension(10000) :: IPOSV 
+         INTEGER, dimension(100) :: IPOSV 
       END MODULE IP_ARRAY 
 C 
       SUBROUTINE RADAR5(N,FCN,PHI,ARGLAG,X,Y,XEND,H, 
@@ -52,8 +52,7 @@
      &                  JACLAG,NLAGS,NJACL, 
      &                  IMAS,SOLOUT,IOUT, 
      &                  WORK,IWORK,RPAR,IPAR,IDID, 
-     &                  GRID,IPAST,MAS,MLMAS,MUMAS,
-     &                  PAST,LRPAST) 
+     &                  GRID,IPAST,MAS,MLMAS,MUMAS) 
 C ---------------------------------------------------------- 
 C     INPUT PARAMETERS   
 C --------------------   
@@ -483,19 +482,16 @@
       INTEGER, PARAMETER :: DP=kind(1D0) 
       REAL(kind=DP), dimension(N), intent(inout) ::  
      &                             Y 
-      REAL(kind=DP), dimension(30), intent(inout) ::  
+      REAL(kind=DP), dimension(1), intent(inout) ::  
      &                             WORK 
       REAL(kind=DP), dimension(1), intent(inout) ::  
      &                             ATOL,RTOL 
-      INTEGER, dimension(30), intent(inout) :: IWORK 
+      INTEGER, dimension(1), intent(inout) :: IWORK 
       REAL(kind=DP), dimension(1), intent(inout) :: GRID 
       INTEGER, dimension(1), intent(inout) :: IPAST 
       REAL(kind=DP), dimension(1), intent(in) :: RPAR 
       INTEGER, dimension(1), intent(in) :: IPAR 
  
-      REAL(kind=DP), dimension(LRPAST), intent(inout) :: PAST
-      INTEGER, intent(in) :: LRPAST
- 
       LOGICAL IMPLCT,NEUTRAL,JBAND,ARRET,STARTN,PRED 
       LOGICAL FLAGS,FLAGN 
  
@@ -524,7 +520,7 @@
        FLAGS=.FALSE. 
        FLAGN=.FALSE. 
  
-C       IF (IOUT.EQ.1) WRITE (6,*) 'STARTING INTEGRATION...' 
+       IF (IOUT.EQ.1) WRITE (6,*) 'STARTING INTEGRATION...' 
 C        
 C ------> OPERATIONS RELEVANT TO THE DELAY DEPENDENCE <------ 
 C 
@@ -538,20 +534,20 @@
 C -------- NGRID   NUMBER OF PRESCRIBED GRID-POINTS 
       NGRID=IWORK(13) 
       IF (NGRID.LT.0) NGRID=0 
-C      IF (IOUT.EQ.1) WRITE(6,*)  
-C     &           'NUMBER OF PRESCRIBED GRID POINTS: ',NGRID 
+      IF (IOUT.EQ.1) WRITE(6,*)  
+     &           'NUMBER OF PRESCRIBED GRID POINTS: ',NGRID 
 C ------- NRDENS   NUMBER OF DENSE OUTPUT COMPONENTS 
       NRDENS=IWORK(15)
 C ------- NDIMN   NUMBER OF COMPONENTS OF A NEUTRAL PROBLEM
       IF (IMAS.EQ.2) THEN
-      IF (IWORK(16).EQ.0) THEN
-       WRITE(6,*) 'NUMBER OF Y COMPONENTS HAS TO BE SPECIFIED'
-       ARRET=.TRUE.
-      END IF
-       NDIMN=IWORK(16)
-      ELSE 
-       NDIMN=N
-      END IF     
+	 IF (IWORK(16).EQ.0) THEN
+	  WRITE(6,*) 'NUMBER OF Y COMPONENTS HAS TO BE SPECIFIED'
+	  ARRET=.TRUE.
+	 END IF
+	 NDIMN=IWORK(16)
+	ELSE 
+	 NDIMN=N
+	END IF  	 
 C ------- LIPAST   DIMENSION OF VECTOR IPAST 
       LIPAST=NRDENS+1  
       IF(NRDENS.LT.0.OR.NRDENS.GT.N) THEN 
@@ -567,7 +563,7 @@
             DO 16 I=1,NRDS 
   16           IPAST(I)=I 
       END IF 
-C      IF (IOUT.EQ.1) WRITE(6,*) 'NUMBER OF DELAYED COMPONENTS: ',NRDS 
+      IF (IOUT.EQ.1) WRITE(6,*) 'NUMBER OF DELAYED COMPONENTS: ',NRDS 
 C ------- LRPAST   DIMENSION OF VECTOR PAST 
       MXST=IWORK(12) 
 C ------- CONTROL OF LENGTH OF PAST  ------- 
@@ -578,8 +574,7 @@
       END IF 
 C ------- DIM. of PAST  -------- 
       IDIF=4*NRDS+2 
-C      LRPAST=MXST*IDIF 
-C      WRITE (6,*) ' AT INITIALIZATION, LRPAST = ',LRPAST 
+      LRPAST=MXST*IDIF 
 C -------------------------------------------------  
 C ------- CONTROL OF SIMPLE NEWTON ITERATION  ------- 
       ISWJL=IWORK(14) 
@@ -740,11 +735,6 @@
          NGRID=NGRID+1 
       END IF 
       GRID(NGRID)=XEND 
-      
-C      WRITE(6,*) 'FINAL GRID: '
-C      DO I = 1, NGRID
-C        WRITE(6,*) GRID(I)
-C      END DO
 C -------------------------------------------------------  
  
 C -------> MAXIMAL STEP SIZE <------- 
@@ -784,9 +774,9 @@
       END IF 
 C ------->   PARAMETER FOR CONTROLLING THE SEARCH OF BP <-------
       TCKBP=WORK(11)
-      IF (TCKBP.LE.0.D0) THEN
-           TCKBP=5.D0
-      END IF           
+	IF (TCKBP.LE.0.D0) THEN
+	      TCKBP=5.D0
+	END IF	       
    
 C *** *** *** *** *** *** *** *** *** *** *** *** *** 
 C         COMPUTATION OF ARRAY ENTRIES 
@@ -847,11 +837,9 @@
          IDID=-1 
          RETURN 
       END IF 
-C      WRITE(6,*), (IWORK(j), j = 1,30)
-C      WRITE(6,*), (WORK(j), j = 1,30)
-C  136 format (30I3.1)
+ 
 C     NUMERICAL KERNEL
-C      WRITE(6,*) 'INTEGRATION...'
+      WRITE(6,*) 'INTEGRATION...'
 C -------- CALL TO CORE INTEGRATOR ------------ 
       CALL RADCOR(N,X,Y,XEND,H,FCN,PHI,ARGLAG,RTOL,ATOL,ITOL, 
      &   JAC,IJAC,MLJAC,MUJAC,JACLAG,MAS,MLMAS,MUMAS,SOLOUT,IOUT,IDID, 
@@ -860,8 +848,7 @@
      &   IMPLCT,NEUTRAL,NDIMN,JBAND,LDJAC,LDE1,LDMAS2, 
      &   NFCN,NJAC,NSTEP,NACCPT,NREJCT,NDEC,NSOL,NFULL,RPAR,IPAR, 
      &   IPAST,GRID,NRDS,NLAGS,NJACL, 
-     &   NGRID,IEFLAG,WORK(7),TCKBP,ALPHA,ISWJL,
-     &   PAST,LRPAST) 
+     &   NGRID,IEFLAG,WORK(7),TCKBP,ALPHA,ISWJL) 
       IWORK(13)=NFULL 
       IWORK(14)=NFCN 
       IWORK(15)=NJAC 
@@ -900,8 +887,7 @@
      &   IMPLCT,NEUTRAL,NDIMN,BANDED,LDJAC,LDE1,LDMAS, 
      &   NFCN,NJAC,NSTEP,NACCPT,NREJCT,NDEC,NSOL,NFULL,RPAR,IPAR, 
      &   IPAST,GRID,NRDS,NLAGS,NJACL, 
-     &   NGRID,IEFLAG,WORK7,TCKBP,ALPHA,ISWJL,
-     &   PAST,LRPAST) 
+     &   NGRID,IEFLAG,WORK7,TCKBP,ALPHA,ISWJL) 
 C ---------------------------------------------------------- 
 C     CORE INTEGRATOR FOR RADAR5 
 C     PARAMETERS SAME AS IN RADAR5 WITH WORKSPACE ADDED  
@@ -914,8 +900,7 @@
       INTEGER, PARAMETER :: DP=kind(1D0) 
       REAL(kind=DP), dimension(1), intent(inout) :: Y 
       REAL(kind=DP), dimension(:), allocatable ::  
-     &                              Z1,Z2,Z3,Y0,SCAL,F1,F2,F3,CONT
-      REAL(kind=DP), dimension(LRPAST), intent(inout) :: PAST 
+     &                              Z1,Z2,Z3,Y0,SCAL,F1,F2,F3,CONT,PAST 
       REAL(kind=DP), dimension(:), allocatable :: BPV,UCONT 
       REAL(kind=DP), dimension(:,:), allocatable ::  
      &                              FJAC,FJACS,FMAS,E1,E2R,E2I 
@@ -936,8 +921,6 @@
      &                              IVL,IVE,IVC,ILS 
       INTEGER, dimension(:), allocatable ::  
      &                              IP1,IP2,IPHES,IPJ 
-C      INTEGER :: LRPAST
-       INTEGER, intent(in) :: LRPAST
  
       LOGICAL FLAGS,FLAGN,FLAGUS 
       LOGICAL QUADR 
@@ -965,9 +948,7 @@
       IF (IMPLCT) ALLOCATE(FMAS(LDMAS,NM1)) 
       ALLOCATE (IP1(NM1),IP2(NM1),IPHES(NM1)) 
       ALLOCATE (E1(LDE1,NM1),E2R(LDE1,NM1),E2I(LDE1,NM1)) 
-C      LRPAST = MXST*IDIF
-C      ALLOCATE (PAST(MXST*IDIF)) 
-C      WRITE (6,*) ' IN RADCOR, LRPAST = ',LRPAST
+      ALLOCATE (PAST(MXST*IDIF)) 
       IF (NLAGS.GT.0) THEN 
        ALLOCATE (FJACS(LDJAC,N),FJACLAG(NJACL)) 
        ALLOCATE (IVL(NJACL),IVE(NJACL),IVC(NJACL), 
@@ -983,8 +964,8 @@
       ALLOCATE (CONT(LRC)) 
       ALLOCATE (UCONT(LRC+2)) 
 C --- 
-C       OPEN(8,FILE='radar5.log')
-C       REWIND 8
+       OPEN(8,FILE='radar5.log')
+       REWIND 8
 
 C -------------------------------------------------  
       BPC=.FALSE. 
@@ -995,11 +976,9 @@
       CALLAG=.FALSE. 
       IACT=1 
       IPOS=1 
-C      DO I=1,NLAGS 
-       DO I=1, SIZE(IPOSV)
+      DO I=1,NLAGS 
        IPOSV(I)=1 
       END DO 
-C      WRITE(6,*) 'INIT IPOSV', IPOSV(1),NLAGS
       X0B=X 
       DO I=1,NGRID 
        IF (GRID(I).GT.X0B) THEN  
@@ -1019,21 +998,18 @@
       ERRACC=1.D0
  
       IRTRN=2 
-C      WRITE(6,*) 'INIT FCN6'
-      CALL FCN(N,X,Y,Y0,ARGLAG,PHI,RPAR,IPAR,PAST,IPAST,NRDS,
-     &  LRPAST) 
-C      WRITE(6,*) 'END INIT FNC6'
+      CALL FCN(N,X,Y,Y0,ARGLAG,PHI,RPAR,IPAR,PAST,IPAST,NRDS) 
       IRTRN=1 
  
 C     TOLMIN
       IF (ITOL.EQ.0) THEN
+	 RTOLM=RTOL(1)
+	ELSE
        RTOLM=RTOL(1)
-      ELSE
-       RTOLM=RTOL(1)
        DO I=2,N
         IF (RTOL(I).LT.RTOLM) RTOLM=RTOL(I)
-       END DO
-      END IF
+	 END DO
+	END IF
  
 C -------- CHECK THE INDEX OF THE PROBLEM -----  
       INDEX1=NIND1.NE.0 
@@ -1106,15 +1082,12 @@
       REJECT=.FALSE. 
       FIRST=.TRUE. 
       LAST=.FALSE. 
-      NITER=0
+	NITER=0
       IF ((X+H*1.0001D0-XEND).GE.0.D0) THEN 
          H=XEND-X 
          LAST=.TRUE. 
       END IF 
-C ---  INITIALIZATION FOR THE ARRAY PAST
-        DO I=1,MXST*IDIF
-           PAST(I)=0.D0
-        ENDDO
+C ---  INITIALIZATION FOR THE ARRAY PAST    
        DO 3 I=0,MXST-1 
           PAST(1+IDIF*I)=X  
    3   CONTINUE 
@@ -1126,8 +1099,6 @@
           PAST(J+2*NRDS+IPA)=0.D0 
           PAST(J+3*NRDS+IPA)=0.D0 
        ENDDO 
-C       WRITE (6,*) 
-C     &        ' THE INITIALIZATION WAS RUN.', X, Y(1), H
           PAST(IPA+IDIF-1)=H  
 C ---  END OF THE INITIALIZATION      
       FACCON=1.D0 
@@ -1167,26 +1138,7 @@
       HHFAC=H 
       NFCN=NFCN+1 
  
-      NFULL=0
-      
-C      WRITE(6,*) 'COMMON BLOCKS'
-C      WRITE(6,*) XEND,IGRID
-C      PRINT *, GRID 
-C      PRINT *, IVL
-C      ,IVE,IVC,ILS
-C      WRITE(6,*) FLAGS,FLAGN,FLAGUS,QUADR BPC,BPD,BPDMEM,LEFT,REPEAT
-C      WRITE(6,*) REJECT,FIRST,IMPLCT,NEUTRAL,PROJECT,BANDED,CALJAC 
-C      WRITE(6,*) STARTN,CALHES,CALJACL,CALLAG 
-C      WRITE(6,*) INDEX1,INDEX2,INDEX3,LAST,PRED
-C      PRINT *, ATOL, RTOL
-C      WRITE(6,*) X0B,UROUND,HMAX,IACT,IRTRN,IDIF,MXST,FLAGS,FLAGN 
-C      WRITE(6,*) C1,C2,C1M1,C2M1,C1MC2 
-C      WRITE(6,*) FIRST,LAST,REJECT,BPD 
-C      WRITE(6,*) BPP,ILBP,LEFT 
-C      WRITE(6,*) MLE,MUE,MBJAC,MBB,MDIAG,MDIFF,MBDIAG
-C      WRITE(6,137) ( IPOSV(j), j=1,100 ) 
-
-C  137 format (100I3.1)
+      NFULL=0 
 C -------------------------- 
 C --- BASIC INTEGRATION STEP   
 C -------------------------- 
@@ -1200,9 +1152,9 @@
 C ----------------------- 
       ALOPT=0.D0 
       NJAC=NJAC+1 
-      IF (BPD) THEN
-       BPDMEM=.TRUE.
-       BPD=.FALSE.
+	IF (BPD) THEN
+	 BPDMEM=.TRUE.
+	 BPD=.FALSE.
       END IF
       IF (IJAC.EQ.0) THEN 
 C --- COMPUTE JACOBIAN MATRIX NUMERICALLY 
@@ -1217,12 +1169,9 @@
                   F2(J)=DSQRT(UROUND*MAX(1.D-5,ABS(Y(J)))) 
                   Y(J)=Y(J)+F2(J) 
                   J=J+MD 
-                  IF (J.LE.MM*M2) GOTO 12
-C                  WRITE(6,*) 'BANDED JAC FCN9'
+                  IF (J.LE.MM*M2) GOTO 12  
                   CALL FCN(N,X,Y,CONT,ARGLAG,PHI,RPAR,IPAR,PAST,IPAST,
-     &                     NRDS,
-     &  LRPAST) 
-C                  WRITE(6,*) 'END BANDED JAC FCN9'
+     &                     NRDS) 
                   J=K+(MM-1)*M2 
                   J1=K 
                   LBEG=MAX(1,J1-MUJAC)+M1 
@@ -1242,14 +1191,11 @@
 C --- JACOBIAN IS FULL 
             DO I=1,N 
                YSAFE=Y(I) 
-              DELT=DSQRT(UROUND*MAX(1.D-5,ABS(YSAFE))) 
-                Y(I)=YSAFE+DELT
-C                 WRITE(6,*) 'JAC FCN8'
+	         DELT=DSQRT(UROUND*MAX(1.D-5,ABS(YSAFE))) 
+			 Y(I)=YSAFE+DELT 
                  CALL FCN(N,X,Y,CONT,ARGLAG,PHI, 
-     &                  RPAR,IPAR,PAST,IPAST,NRDS,
-     &  LRPAST) 
-C                 WRITE(6,*) 'END JAC FCN8'
-              DO J=M1+1,N 
+     1	              RPAR,IPAR,PAST,IPAST,NRDS)
+	         DO J=M1+1,N 
                  FJAC(J-M1,I)=(CONT(J)-Y0(J))/DELT 
                END DO 
                Y(I)=YSAFE 
@@ -1257,12 +1203,11 @@
          END IF 
       ELSE 
 C --- COMPUTE JACOBIAN MATRIX ANALYTICALLY
-         CALL JAC(N,X,Y,FJAC,LDJAC,ARGLAG,PHI,RPAR,IPAR,PAST,IPAST,
-     &   NRDS) 
+         CALL JAC(N,X,Y,FJAC,LDJAC,ARGLAG,PHI,RPAR,IPAR,PAST,IPAST,NRDS) 
       END IF
-      IF (BPDMEM) THEN
-      BPDMEM=.FALSE.
-      BPD=.TRUE.
+	IF (BPDMEM) THEN
+	 BPDMEM=.FALSE.
+	 BPD=.TRUE.
       END IF 
       CALJAC=.TRUE. 
       CALHES=.TRUE. 
@@ -1350,14 +1295,11 @@
 C ---  LOOP ON LAG TERMS 
        DO IL=1,NLAGS 
 C ---   DELAYED ARGUMENTS ARE COMPUTED 
-        XLAG(1,IL)=ARGLAG(IL,X1,ZL,RPAR,IPAR,PHI,PAST,IPAST,NRDS,
-     &  LRPAST, N) 
+        XLAG(1,IL)=ARGLAG(IL,X1,ZL,RPAR,IPAR,PHI,PAST,IPAST,NRDS) 
            IF (XLAG(1,IL).GT.X) ICOUN(1,IL)=1 
-        XLAG(2,IL)=ARGLAG(IL,X2,ZL(N+1),RPAR,IPAR,PHI,PAST,IPAST,NRDS,
-     &  LRPAST, N)  
+        XLAG(2,IL)=ARGLAG(IL,X2,ZL(N+1),RPAR,IPAR,PHI,PAST,IPAST,NRDS) 
            IF (XLAG(2,IL).GT.X) ICOUN(2,IL)=1 
-        XLAG(3,IL)=ARGLAG(IL,X3,ZL(N2+1),RPAR,IPAR,PHI,PAST,IPAST,NRDS,
-     &  LRPAST, N)  
+        XLAG(3,IL)=ARGLAG(IL,X3,ZL(N2+1),RPAR,IPAR,PHI,PAST,IPAST,NRDS) 
            IF (XLAG(3,IL).GT.X) ICOUN(3,IL)=1 
         IF (ICOUN(1,IL)+ICOUN(2,IL)+ICOUN(3,IL).GE.1) CALJACL=.TRUE.
        END DO 
@@ -1431,7 +1373,7 @@
             IK=IVE(KK) 
             JK=IVC(KK) 
             FJAC(IK,JK)=FJAC(IK,JK)+ALOPT*FJACLAG(KK)
-C                       ----S         
+C                       ----S		   
            END DO 
           ELSE 
            CALJACL=.FALSE. 
@@ -1550,42 +1492,30 @@
              ZL(I+N2)=A1+Z3(I) 
             END DO 
 C           COMPUTATION OF STAGE VALUES
-C           WRITE(6,*) 'STAGE FCN3'
             CALL FCN(N,X+C1*H,ZL,Z1,ARGLAG,PHI,RPAR,IPAR,PAST,
-     &               IPAST,NRDS,
-     &  LRPAST) 
+     &               IPAST,NRDS) 
             CALL FCN(N,X+C2*H,ZL(N+1),Z2,ARGLAG,PHI,RPAR,IPAR,PAST,
-     &               IPAST,NRDS,
-     &  LRPAST) 
-C            WRITE(6,*) 'END STAGE FCN3'
+     &               IPAST,NRDS)
             IF (BPD) THEN
 C ---------------------------------------------------------------------- 
 C ---         A BREAKING POINT HAS BEEN DETECTED
 C ---------------------------------------------------------------- 
               LEFT=.FALSE. 
-C            WRITE(6,*) 'Calling arglag (1)'
               DBP=ARGLAG(ILBP,X+C2*H,ZL(N+1),RPAR,IPAR,PHI, 
-     &                   PAST,IPAST,NRDS,
-     &  LRPAST,N) 
+     &                   PAST,IPAST,NRDS) 
               IF (DBP.LT.BPP) LEFT=.TRUE. 
             ELSE IF (LAST) THEN 
 C ---         DISC. FLAG 
               XX=(X+H)*(1.D0-BTOL) 
               DO I=1,N 
                  ZL(N2+I)=(1.D0-BTOL)*ZL(N2+I)+BTOL*ZL(N+I) 
-              END DO
-C              WRITE(6,*) 'BREAKING FCN4'
+              END DO 
               CALL FCN(N,XX,ZL(N2+1),Z3,ARGLAG,PHI,RPAR,IPAR,PAST, 
-     &                 IPAST,NRDS,
-     &  LRPAST)
-C              WRITE(6,*) 'END BREAKING FCN4'
+     &                 IPAST,NRDS) 
               GO TO 42 
-            END IF
-C            WRITE(6,*) 'DETECTED FCN5'
+            END IF 
             CALL FCN(N,X+H,ZL(N2+1),Z3,ARGLAG,PHI,RPAR,IPAR,PAST, 
-     &               IPAST,NRDS,
-     &  LRPAST) 
-C            WRITE(6,*) 'END DETECTED FCN5'
+     &               IPAST,NRDS) 
  42         CONTINUE
     
             NFCN=NFCN+3 
@@ -1606,10 +1536,10 @@
             NSOL=NSOL+1 
             NEWT=NEWT+1 
 C ---       NORM OF DY 
-            DYNO=0.D0 
-           DO I=1,N
+		  DYNO=0.D0 
+	      DO I=1,N
             END DO
-            DO I=1,N 
+		  DO I=1,N 
                DENOM=SCAL(I) 
                DYNO=DYNO+(Z1(I)/DENOM)**2+(Z2(I)/DENOM)**2 
      &          +(Z3(I)/DENOM)**2 
@@ -1619,12 +1549,10 @@
 C ---     BAD CONVERGENCE OR NUMBER OF ITERATIONS TO LARGE 
 C --------------------------------------------------------
             IF (NEWT.GT.1.AND.NEWT.LT.NIT) THEN 
-C               WRITE(6,*) 'DYNOLD:', DYNOLD
                 THQ=DYNO/DYNOLD 
                 IF (NEWT.EQ.2) THEN 
                    THETA=THQ 
                 ELSE 
-C                   WRITE(6,*) 'THQOLD:', THQOLD
                    THETA=SQRT(THQ*THQOLD) 
                 END IF 
                 THQOLD=THQ 
@@ -1658,7 +1586,6 @@
                BPD=.FALSE.
               END IF
               HP=H*0.99D0
-              WRITE(6,*) 'Calling BPDTCT from row 1661.'
               CALL BPDTCT(N,X,HP,Y,ARGLAG,RPAR,IPAR,UCONT,GRID,NLAGS, 
      &                    FIRST,LAST,XEND,IGRID,BPV,IBP,ILBP,BPP,BPD, 
      &                    KMAX,PHI,PAST,IPAST,NRDS) 
@@ -1699,7 +1626,7 @@
                 QNEWT=DMAX1(1.0D-4,DMIN1(20.0D0,DYTH)) 
                 HHFAC=.8D0*QNEWT**(-1.0D0/(4.0D0+NIT-1-NEWT)) 
                 H=HHFAC*H 
-          LAST=.FALSE. 
+		LAST=.FALSE. 
                ELSE IF (INREJ.EQ.2) THEN 
                 H=H*0.55D0 
                 HHFAC=0.55D0 
@@ -1743,29 +1670,29 @@
 C ---       ITERATIVE CORRECTION OF THE BREAKING POINT
 C ----------------------------------------------------------------
             IF (BPD) THEN
-          HNEWT=H
-          NITER = NITER+1
-          IF (NITER.GT.NIT) THEN  
+	     HNEWT=H
+	     NITER = NITER+1
+	     IF (NITER.GT.NIT) THEN  
 C              BP WRONG                 
                IBP=IBP-1 
                BPD=.FALSE. 
                LAST=.FALSE. 
                H=H*0.55D0 
                HHFAC=0.55D0
-            REJECT=.TRUE.
-            NITER=0 
+	       REJECT=.TRUE.
+	       NITER=0 
                IF (CALJAC) GOTO 20 
                GOTO 10   
              END IF  
-              
+		    
              CALL BPACC(N,X,H,Y,ARGLAG,RPAR,IPAR,Z1,Z2,Z3,FIRST,
      &                  BPV,IBP,ILBP,BPP,KMAX,PHI,PAST,IPAST,NRDS) 
              IF (ABS(H-HNEWT)/HNEWT.GE.MAX(BTOL,RTOLM*1.D-2)) THEN
               GOTO 20
 C             REF POINT
              ELSE
-             H=HNEWT
-             NITER=0
+	        H=HNEWT
+	        NITER=0
              END IF
             END IF  
 C ----------------------------------------------------------------
@@ -1961,19 +1888,14 @@
             END IF 
 C ---     COMPUTE THE RIGHT-HAND SIDE 
             CONT(1:N)=Y(1:N)+Z1(1:N) 
-C            WRITE(6,*) 'FCN1'
             CALL FCN(N,X+C1*H,CONT,F1,ARGLAG,PHI,RPAR,IPAR,PAST,
-     &               IPAST,NRDS,
-     &  LRPAST) 
+     &               IPAST,NRDS) 
             CONT(1:N)=Y(1:N)+Z2(1:N) 
             CALL FCN(N,X+C2*H,CONT,F2,ARGLAG,PHI,RPAR,IPAR,PAST,
-     &               IPAST,NRDS,
-     &  LRPAST) 
+     &               IPAST,NRDS) 
             CONT(1:N)=Y(1:N)+Z3(1:N) 
             CALL FCN(N,XPH,CONT,F3,ARGLAG,PHI,RPAR,IPAR,PAST,
-     &               IPAST,NRDS,
-     &  LRPAST)
-C            WRITE(6,*) 'FCN2'
+     &               IPAST,NRDS) 
             NFCN=NFCN+3 
 C 
 CCC --->    RHS COMPUTATION 
@@ -2094,7 +2016,7 @@
      &              FCN,NFCN,Y0,Y,IJOB,X,M1,M2,NM1,E1,LDE1,ALPHA, 
      &              Z1,Z2,Z3,CONT,F1,F2,F3,IP1,IPHES,SCAL,SERR,CERR, 
      &              FIRST,REJECT,FAC1,ARGLAG,PHI,RPAR,IPAR, 
-     &              IOUT,PAST,IPAST,NRDS,JLFLAG,IEFLAG,LRPAST) 
+     &              IOUT,PAST,IPAST,NRDS,JLFLAG,IEFLAG) 
  
       FAC=MIN(SAFE,CFAC/(NEWT+2*NIT)) 
  
@@ -2151,7 +2073,6 @@
         ELSE
 C ---     LOOK FOR A BP        
           HP=H*0.99D0
-C          WRITE(6,*) 'Calling BPDTCT from row 2154.'
           CALL BPDTCT(N,X,HP,Y,ARGLAG,RPAR,IPAR,UCONT,GRID,NLAGS, 
      &                FIRST,LAST,XEND,IGRID,BPV,IBP,ILBP,BPP,BPD,
      &                KMAX,PHI,PAST,IPAST,NRDS) 
@@ -2177,7 +2098,6 @@
 C --------> PREDICTIVE CONTROLLER OF GUSTAFSSON 
             IF (NACCPT.GT.1) THEN 
              IF (FLAGUS) THEN 
-C               WRITE(6,*) 'HACC:', HACC
                FACGUS=(HACC/H)*(ERR**2/ERRACC)**0.25D0/SAFE 
                FACGUS=MAX(FACR,MIN(FACL,FACGUS)) 
                QUOT=MAX(QUOT,FACGUS) 
@@ -2221,7 +2141,7 @@
               CONT(I+N3)=A2-ACONT3 
             ELSE 
 C ---         QUADRATIC APPROXIMATION
-              CONT(I+N3)=0.D0           
+              CONT(I+N3)=0.D0			
 C ---         INVECE DI:  
 C ---         CONT(I+N3)=CONT(I+N2)-ACONT3 
             END IF 
@@ -2267,9 +2187,8 @@
          IF (LAST) THEN 
 C ---     LAST HAS TO BE RE/DEFINED
           IF (BPD) THEN 
-           WRITE(6,*) 'Found a BP at ', X, ', decrementing IGRID.'
            IGRID=IGRID-1
-       END IF 
+	  END IF 
 C --- 
           IF (.NOT.IMPLCT.OR.NEUTRAL) THEN  ! EXPLICIT PROBLEM
             HE=DMAX1(H/1.D4,10.D0*UROUND) 
@@ -2278,80 +2197,70 @@
 C -------------------- 
 C --- 
 C ---       EULER STEP
-C            WRITE(6,*) 'EULER STEP FCN6'
-            CALL FCN(N,X,Y,F2,ARGLAG,PHI,RPAR,IPAR,PAST,IPAST,NRDS,
-     &  LRPAST)
-C            WRITE(6,*) 'END EULER STEP FCN6'
+            CALL FCN(N,X,Y,F2,ARGLAG,PHI,RPAR,IPAR,PAST,IPAST,NRDS) 
             IF (NEUTRAL) THEN
-             DO I=1,N-NDIMN 
+	        DO I=1,N-NDIMN 
                Z2(I)=Y(I)+HE*F2(I) 
               END DO
-              DO I=1,NDIMN
-              Z2(N-NDIMN+I)=F2(IPAST(NRDS+I))+HE*F2(N-NDIMN+I)
-             END DO
+		    DO I=1,NDIMN
+	         Z2(N-NDIMN+I)=F2(IPAST(NRDS+I))+HE*F2(N-NDIMN+I)
+	        END DO
             ELSE
-              DO I=1,N 
+		    DO I=1,N 
                Z2(I)=Y(I)+HE*F2(I) 
               END DO
-            END IF  
+		  END IF  
 C -------------------- 
             LEFT=.FALSE. 
 C -------------------- 
-C            WRITE(6,*) 'SECOND EULER STEP FCN6'
-            CALL FCN(N,X,Y,F3,ARGLAG,PHI,RPAR,IPAR,PAST,IPAST,NRDS,
-     &  LRPAST)
-C            WRITE(6,*) 'END SECOND EULER STEP FCN6'
+            CALL FCN(N,X,Y,F3,ARGLAG,PHI,RPAR,IPAR,PAST,IPAST,NRDS) 
             IF (NEUTRAL) THEN
-             DO I=1,N-NDIMN 
+	        DO I=1,N-NDIMN 
                Z3(I)=Y(I)+HE*F3(I) 
               END DO
-              DO I=1,NDIMN
-              Z3(N-NDIMN+I)=F3(IPAST(NRDS+I))+HE*F3(N-NDIMN+I)
-             END DO
+		    DO I=1,NDIMN
+	         Z3(N-NDIMN+I)=F3(IPAST(NRDS+I))+HE*F3(N-NDIMN+I)
+	        END DO
             ELSE
-              DO I=1,N 
+		    DO I=1,N 
                Z3(I)=Y(I)+HE*F3(I) 
               END DO 
             END IF
-C            WRITE(6,*) 'Calling arglag (2), ILBP = ', ILBP
-            XL =ARGLAG(ILBP,X+HE,Z2,RPAR,IPAR,PHI,PAST,IPAST,NRDS,
-     &  LRPAST,N)  
-C            WRITE(6,*) 'Calling arglag (3)'
-            XLR=ARGLAG(ILBP,X+HE,Z3,RPAR,IPAR,PHI,PAST,IPAST,NRDS,
-     &  LRPAST,N)  
+            XL =ARGLAG(ILBP,X+HE,Z2,RPAR,IPAR,PHI,PAST,IPAST,NRDS) 
+            XLR=ARGLAG(ILBP,X+HE,Z3,RPAR,IPAR,PHI,PAST,IPAST,NRDS) 
             IF (XL.GE.BPP.AND.XLR.GE.BPP) THEN 
              LEFT=.FALSE. 
             ELSE IF (XL.LT.BPP.AND.XLR.LT.BPP) THEN 
              LEFT=.TRUE. 
             ELSE 
              IF (IOUT.EQ.1) THEN 
-              IF (XL.GT.BPP) THEN
-                WRITE (6,*) 
+		    IF (XL.GT.BPP) THEN
+			 WRITE (6,*) 
      &        ' WARNING!: SOLUTION DOES NOT EXIST AT X= ',X
               ELSE
-              WRITE (6,*) 
+	         WRITE (6,*) 
      &        ' WARNING!: SOLUTION IS  NOT UNIQUE AT X= ',X
-             END IF
+	        END IF
               GO TO 980
 C             RETURN 
              END IF
             END IF
 C ---       PROJECTION FOR DERIVATIVE COMPONENTS OF NEUTRAL EXPLICIT PROBLEMS
             PROJECT=.TRUE.
-         IF (NEUTRAL.AND.PROJECT) THEN
-            IF (LEFT) THEN
-              DO J=1,NDIMN
-              Y(N-NDIMN+J)=F2(IPAST(NRDS+J))
-             END DO
+	    IF (NEUTRAL.AND.PROJECT) THEN
+	       IF (LEFT) THEN
+		    DO J=1,NDIMN
+	         Y(N-NDIMN+J)=F2(IPAST(NRDS+J))
+	        END DO
             ELSE
-             DO J=1,NDIMN
-              Y(N-NDIMN+J)=F3(IPAST(NRDS+J))
-             END DO
+	        DO J=1,NDIMN
+	         Y(N-NDIMN+J)=F3(IPAST(NRDS+J))
+	        END DO
+	       END IF
             END IF
-            END IF
-       ELSE ! GENERAL IMPLICIT
-           LEFT=.TRUE.
-       END IF
+	  ELSE ! GENERAL IMPLICIT
+	      LEFT=.TRUE.
+	  END IF
 C --- 
           BPD=.FALSE. 
          END IF  
@@ -2385,21 +2294,16 @@
          FIRST=.FALSE. 
          IF (LAST) FIRST=.TRUE. 
 C ---    COMPUTATION OF Y0 
-C        WRITE(6,*) 'ERROR ELLER?' 
-         CALL FCN(N,X,Y,Y0,ARGLAG,PHI,RPAR,IPAR,PAST,IPAST,NRDS,
-     &  LRPAST) 
-C       
+         CALL FCN(N,X,Y,Y0,ARGLAG,PHI,RPAR,IPAR,PAST,IPAST,NRDS)
+C	   
          NFCN=NFCN+1 
          FIRST=.FALSE.  
 C ----------------------------- 
-      
+	 
 C ------ FINAL POINT                               
-C         WRITE(6, *) 'X:', X
-C         WRITE(6, *) 'IGRID:', IGRID
          IF (LAST) THEN 
  45         CONTINUE
             IF (IGRID.EQ.NGRID) THEN 
-C               WRITE(6,*) 'HOPT:', HOPT
                H=HOPT 
                IDID=1 
 C ---          END OF COMPUTATION 
@@ -2411,10 +2315,10 @@
 C              LEFT=.FALSE. 
                FIRST=.TRUE. 
                XEND=GRID(IGRID)
-            IF (ABS(XEND-X).LE.(H*1.D-2)) THEN
-            IGRID=IGRID+1
-            GO TO 45 
-            END IF 
+	       IF (ABS(XEND-X).LE.(H*1.D-2)) THEN
+		  IGRID=IGRID+1
+		  GO TO 45 
+	       END IF 
                FLAGUS=.FALSE. 
                IF (WORK7.EQ.0.D0) THEN 
                   HMAXN=XEND-X  
@@ -2423,8 +2327,7 @@
                HNEW=MIN(HNEW,H)
             END IF 
          END IF 
-C         WRITE(6,*) 'Before updating hnew and hopt'
-C         WRITE(6, *) 'IGRID:', IGRID
+ 
          HNEW=MIN(HNEW,HMAXN) 
          HOPT=MIN(H,HNEW) 
          IF (REJECT) HNEW=MIN(HNEW,H)  
@@ -2551,13 +2454,13 @@
  
 C --- RETURN LABEL 
  980  CONTINUE 
-C      WRITE(6,*) IBP-1,' COMPUTED BREAKING POINTS: '
-C      WRITE(8,*) 'BREAKING POINTS: '
-C      DO I=1,IBP
-C      WRITE(8,*) BPV(I)
-C      END DO
-C      WRITE(8,*) ' -------------- '
-C      CLOSE(8)
+      WRITE(6,*) IBP-1,' COMPUTED BREAKING POINTS: '
+      WRITE(8,*) 'BREAKING POINTS: '
+      DO I=1,IBP
+	WRITE(8,*) BPV(I)
+      END DO
+      WRITE(8,*) ' -------------- '
+      CLOSE(8)
 
 C --- DEALLOCATION OF THE MEMORY 
       DEALLOCATE (Z1,Z2,Z3,Y0,SCAL,F1,F2,F3) 
@@ -2566,7 +2469,7 @@
       IF (IMPLCT) DEALLOCATE(FMAS) 
       DEALLOCATE (IP1,IP2,IPHES) 
       DEALLOCATE (E1,E2R,E2I) 
-C      DEALLOCATE (PAST) 
+      DEALLOCATE (PAST) 
       IF (NLAGS.GT.0) THEN 
        DEALLOCATE (FJACS,FJACLAG) 
        DEALLOCATE (IVL,IVE,IVC,ILS,ICOUN) 
@@ -2584,8 +2487,7 @@
 C *********************************************************** 
 C 
       SUBROUTINE LAGR5(IL,X,Y,ARGLAG,PAST,THETA,IPOS,RPAR,IPAR,
-     &                 PHI,IPAST,NRDS,
-     &                 LRPAST,N)
+     &                 PHI,IPAST,NRDS)
 C ---------------------------------------------------------- 
 C     THIS FUNCTION CAN BE USED FOR CONTINUOUS OUTPUT IN CONNECTION 
 C     WITH THE OUTPUT-SUBROUTINE FOR RADAR5. IT PROVIDES THE 
@@ -2594,31 +2496,21 @@
       USE IP_ARRAY 
       IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
       INTEGER, PARAMETER :: DP=kind(1D0) 
-      REAL(kind=DP), dimension(N), intent(in) :: Y
-      REAL(kind=DP), dimension(LRPAST), intent(in) :: PAST 
+      REAL(kind=DP), dimension(1), intent(in) :: Y,PAST 
       REAL(kind=DP), dimension(1), intent(in) :: RPAR 
       INTEGER, dimension(1), intent(in) :: IPAR 
-      INTEGER, dimension(NRDS), intent(in) :: IPAST 
+      INTEGER, dimension(1), intent(in) :: IPAST 
       EXTERNAL PHI
-       INTEGER, intent(in) :: LRPAST 
-       INTEGER :: N
-       
+
       LOGICAL FLAGS,FLAGN,FIRST,LAST,REJECT,BPD,LEFT 
 C --- COMMON BLOCKS 
       COMMON /BPLOG/FIRST,LAST,REJECT,BPD 
       COMMON /BPCOM/BPP,ILBP,LEFT 
       COMMON /POSITS/X0B,UROUND,HMAX,IACT,IRTRN,IDIF,MXST,FLAGS,FLAGN 
 C 
-C      WRITE(6,*) 'iposv(il) info. IL, IPOSV(IL), IPOS', 
-C     & IL, IPOSV(IL), IPOS
 C --- COMPUTE DEVIATED ARGUMENT FOR IL-TH DELAY 
-C      WRITE(6,*) 'Calling arglag (4)'
-      XLAG=ARGLAG(IL,X,Y,RPAR,IPAR,PHI,PAST,IPAST,NRDS,
-     &  LRPAST,N)
-C      IF (IL .EQ. 10) THEN
-C        WRITE(6, *) 'XLAG = ', XLAG
-C      END IF
-C      WRITE (6,*) ' LRPAST,NRDS,N = ',X,XLAG,X0B, IPOSV(1)
+      XLAG=ARGLAG(IL,X,Y,RPAR,IPAR,PHI,PAST,IPAST,NRDS) 
+
 C --- INITIAL PHASE 
       THETA=XLAG 
       IPOS=-1 
@@ -2628,51 +2520,50 @@
 
       COMPAR=UROUND*MAX(ABS(XLAG),ABS(X0B))
       EPSACT=10.D0*COMPAR
-      IF (IACT.GT.1) EPSACT=DMAX1(PAST(IACT-1)*1.D-2,EPSACT)
+	IF (IACT.GT.1) EPSACT=DMAX1(PAST(IACT-1)*1.D-2,EPSACT)
 
       IF (XLAG.LE.X0B) THEN 
 C ---     DEVIATING ARGUMENT ON THE INITIAL SEGMENT         
         IF (.NOT.((IL.EQ.ILBP).AND.(BPD.OR.FIRST))) THEN 
-          IF (XLAG-X0B.LT.0.D0) THEN
-            RETURN
+	    IF (XLAG-X0B.LT.0.D0) THEN
+	      RETURN
+	    ELSE
+	      IPOS=1
+	      THETA=-1.D0 
+	    END IF
+	  ELSE
+         IF (ABS(XLAG-X0B).LE.EPSACT) THEN
+	    IF (LEFT) THEN
+                IPOS=-1 
+                THETA=XLAG
           ELSE
-            IPOS=1
-            THETA=-1.D0 
+                IPOS=1
+	        THETA=(XLAG-(PAST(IPOS)+PAST(IPOS+IDIF-1)))/
+     1     	PAST(IPOS+IDIF-1) 
           END IF
-        ELSE
-          IF (ABS(XLAG-X0B).LE.EPSACT) THEN
-            IF (LEFT) THEN
-              IPOS=-1 
-              THETA=XLAG
-            ELSE
-              IPOS=1
-              THETA=(XLAG-(PAST(IPOS)+PAST(IPOS+IDIF-1)))/
-     &        PAST(IPOS+IDIF-1) 
-            END IF
-          ELSE IF (ABS(XLAG-BPP).LE.EPSACT) THEN 
-            IPOS=-1 
-            IF (LEFT) THEN 
-              IF (XLAG.GT.BPP) THEN 
-                IF (BPP.GT.0.D0) THEN 
-                  THETA=BPP*(1.D0-100*UROUND) 
-                ELSE 
-                  THETA=BPP*(1.D0+100*UROUND) 
-                END IF 
-              END IF 
+         ELSE IF (ABS(XLAG-BPP).LE.EPSACT) THEN 
+	    IPOS=-1 
+          IF (LEFT) THEN 
+           IF (XLAG.GT.BPP) THEN 
+            IF (BPP.GT.0.D0) THEN 
+              THETA=BPP*(1.D0-100*UROUND) 
             ELSE 
-              IF (XLAG.LT.BPP) THEN 
-                IF (BPP.GT.0) THEN 
-                  THETA=BPP*(1.D0+100*UROUND) 
-                ELSE 
-                  THETA=BPP*(1.D0-100*UROUND) 
-                END IF 
-              END IF 
+              THETA=BPP*(1.D0+100*UROUND) 
             END IF 
-          END IF
-        END IF
-        
-        RETURN
-      END IF 
+           END IF 
+          ELSE 
+           IF (XLAG.LT.BPP) THEN 
+            IF (BPP.GT.0) THEN 
+              THETA=BPP*(1.D0+100*UROUND) 
+            ELSE 
+              THETA=BPP*(1.D0-100*UROUND) 
+            END IF 
+           END IF 
+          END IF 
+         END IF
+	  END IF    
+	  RETURN
+	END IF 
 
 C --- COMPUTE THE POSITION OF XLAG 
       IPA = IACT+IDIF 
@@ -2680,7 +2571,7 @@
       IF (XLAG-PAST(IPA).LT.0.D0) THEN
          WRITE (6,*) ' MEMORY FULL, MXST = ',MXST 
          IRTRN=-1
-        STOP 
+	   STOP 
 C        RETURN 
       END IF 
 
@@ -2690,9 +2581,7 @@
 
 C -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
 C --- INITIALIZE POSITION INSIDE THE MEMORY 
-      IPOS=IPOSV(IL)
-C      IPOS = 1
-C      WRITE(6,*) 'IPOS=', IPOS
+      IPOS=IPOSV(IL) 
 C --- STEP AND DELAYS 
       IF (XLAG-XRIGHT.GT.0.D0) THEN 
         IF (.NOT.FLAGN) THEN 
@@ -2725,7 +2614,7 @@
            IPOS=INEXT 
            GOTO 2 
         END IF
-       IF (IPOS.EQ.1) THEN 
+	  IF (IPOS.EQ.1) THEN 
             IPREV=(MXST-1)*IDIF+1 
         ELSE 
             IPREV=IPOS-IDIF 
@@ -2737,45 +2626,45 @@
         IF (.NOT.((IL.EQ.ILBP).AND.(BPD.OR.FIRST))) GOTO 10
  
         IF (BPP.EQ.X0B) THEN
-         IF (LEFT) THEN
-           IPOS=-1
-           THETA=XLAG
-           RETURN
+	    IF (LEFT) THEN
+	      IPOS=-1
+	      THETA=XLAG
+	      RETURN
           ELSE
-           IF (IPOS.EQ.-1) IPOS=1
-            GO TO 10
-           END IF
+	      IF (IPOS.EQ.-1) IPOS=1
+	       GO TO 10
+	      END IF
         END IF
 
-       IPOSB=0  
-       IF (ABS(BPP-PAST(IPOS)).LE.10.D0*UROUND) THEN
+	  IPOSB=0  
+	  IF (ABS(BPP-PAST(IPOS)).LE.10.D0*UROUND) THEN
            IPOSB=IPOS
-       ELSE IF (ABS(BPP-PAST(INEXT)).LE.10.D0*UROUND) THEN
-          IPOSB=INEXT
-C      ELSE IF (ABS(BPP-PAST(IPREV)).LE.10.D0*UROUND) THEN
-C         IPOSB=IPREV
-       END IF
+	  ELSE IF (ABS(BPP-PAST(INEXT)).LE.10.D0*UROUND) THEN
+	     IPOSB=INEXT
+C	  ELSE IF (ABS(BPP-PAST(IPREV)).LE.10.D0*UROUND) THEN
+C	     IPOSB=IPREV
+	  END IF
 
         IF (IPOSB.EQ.0) THEN
-        GO TO 10
-       END IF
+	   GO TO 10
+	  END IF
 
         IF (IPOSB.EQ.1) THEN
-         EPSILON=(PAST(IPOSB+IDIF)-PAST(IPOSB))
-       ELSE IF (IPOSB.EQ.(MXST-1)*IDIF+1) THEN
-         EPSILON=(PAST(IPOSB)-PAST(IPOSB-IDIF))
-       ELSE
-         EPSILON=DMIN1(PAST(IPOSB+IDIF)-PAST(IPOSB),
+	    EPSILON=(PAST(IPOSB+IDIF)-PAST(IPOSB))
+	  ELSE IF (IPOSB.EQ.(MXST-1)*IDIF+1) THEN
+	    EPSILON=(PAST(IPOSB)-PAST(IPOSB-IDIF))
+	  ELSE
+	    EPSILON=DMIN1(PAST(IPOSB+IDIF)-PAST(IPOSB),
      1                  PAST(IPOSB)-PAST(IPOSB-IDIF))
-       END IF
-       EPSILON=DMAX1(EPSILON*1.D-2,EPSACT)
+	  END IF
+	  EPSILON=DMAX1(EPSILON*1.D-2,EPSACT)
         
         IF (ABS(XLAG-BPP).GT.EPSILON) GOTO 10 
 
         IF (IPOSB.EQ.1) THEN
-         IF (LEFT) THEN 
+	    IF (LEFT) THEN 
                 IPOS=-1 
-C              IF (BPP.GT.0.D0) THEN 
+C	          IF (BPP.GT.0.D0) THEN 
 C                  THETA=BPP*(1.D0-100*UROUND) 
 C               ELSE 
 C                  THETA=BPP*(1.D0+100*UROUND) 
@@ -2783,12 +2672,12 @@
 C               SE PERO' IL DATO INIZIALE E' ESTENDIBILE
                 THETA=XLAG
                 RETURN
-         ELSE 
+	    ELSE 
                 IPOS=1 
-             GO TO 10
-         END IF
+	        GO TO 10
+	    END IF
         END IF
-      
+	 
         IF (LEFT) THEN           
 C ---     PREVIOUS INTERVAL HAS TO BE SELECTED
           IPOS=IPOSB-IDIF
@@ -2800,18 +2689,12 @@
 C --------------------------------------------------------- 
 
 C ----- COMPUTE THETA (<0): SITUAZIONE PIU' TIPICA     
-  10    THETA=(XLAG-(PAST(IPOS)+PAST(IPOS+IDIF-1)))/PAST(IPOS+IDIF-1)
-C        WRITE(6,*) 'SOME STUFF', XLAG, PAST(IPOS), PAST(IPOS+IDIF-1),
-C     &  PAST(IPOS+IDIF-1)
-C        WRITE(6,*) IPOS, IDIF
+  10    THETA=(XLAG-(PAST(IPOS)+PAST(IPOS+IDIF-1)))/PAST(IPOS+IDIF-1) 
 C ----- REM: THETA IS NEGATIVE                                  
-      END IF 
+	END IF 
 C --- UPDATE POSITION INSIDE THE MEMORY 
-C      WRITE(6,*) 'Setting iposv(il) to IPOS. IL, IPOSV(IL), IPOS', 
-C     & IL, IPOSV(IL), IPOS
-      IPOSV(IL)=IPOS
+      IPOSV(IL)=IPOS 
 
-C      WRITE(6,*) 'IN LAGR5, THETA, IPOS', THETA, IPOS
       RETURN 
       END 
 C 
@@ -2821,8 +2704,7 @@
 
 C *********************************************************** 
 C 
-      FUNCTION YLAGR5(IC,THETA,IPOS,PHI,RPAR,IPAR,PAST,IPAST,NRDS,
-     &                LRPAST) 
+      FUNCTION YLAGR5(IC,THETA,IPOS,PHI,RPAR,IPAR,PAST,IPAST,NRDS) 
 C ---------------------------------------------------------- 
 C     THIS FUNCTION CAN BE USED FOR CONTINUOUS OUTPUT IN CONNECTION 
 C     WITH THE SUBROUTINE LAGR5. IT PROVIDES AN APPROXIMATION  
@@ -2834,11 +2716,8 @@
       REAL(kind=DP), dimension(1), intent(in) :: RPAR 
       INTEGER, dimension(1), intent(in) :: IPAR 
 C --- 
-      REAL(kind=DP), dimension(LRPAST), intent(in) :: PAST 
-      INTEGER, dimension(NRDS), intent(in) :: IPAST 
-      
-      INTEGER :: LRPAST
-      
+      REAL(kind=DP), dimension(1), intent(in) :: PAST 
+      INTEGER, dimension(1), intent(in) :: IPAST 
       LOGICAL FLAGS,FLAGN 
 C---- COMMON BLOCKS 
       COMMON /CONSTN/C1,C2,C1M1,C2M1,C1MC2 
@@ -2873,8 +2752,7 @@
  
 C *********************************************************** 
 C 
-      FUNCTION DLAGR5(IC,THETA,IPOS,PHI,RPAR,IPAR,PAST,IPAST,NRDS,
-     &                LRPAST) 
+      FUNCTION DLAGR5(IC,THETA,IPOS,PHI,RPAR,IPAR,PAST,IPAST,NRDS) 
 C ---------------------------------------------------------- 
 C     THIS FUNCTION CAN BE USED FOR CONTINUOUS OUTPUT IN CONNECTION 
 C     WITH THE SUBROUTINE LAGR5. IT PROVIDES AN APPROXIMATION  
@@ -2885,12 +2763,9 @@
 C --- REAL(kind=DP) PHI,DLAGR5
       REAL(kind=DP), dimension(1), intent(in) :: RPAR 
       INTEGER, dimension(1), intent(in) :: IPAR 
-C 
-      REAL(kind=DP), dimension(LRPAST), intent(in) :: PAST 
-      INTEGER, dimension(NRDS), intent(in) :: IPAST 
-      
-       INTEGER :: LRPAST
-      
+CCC  
+      REAL(kind=DP), dimension(1), intent(in) :: PAST 
+      INTEGER, dimension(1), intent(in) :: IPAST 
       LOGICAL FLAGS,FLAGN 
 C---- COMMON BLOCKS 
       COMMON /CONSTN/C1,C2,C1M1,C2M1,C1MC2 
@@ -2918,8 +2793,7 @@
       I=I+IPOS 
       DLAGR5=PAST(NRDS+I)+(THETA-C2M1)*(PAST(2*NRDS+I) 
      &     +(THETA-C1M1)*PAST(3*NRDS+I)) 
-     &     +THETA*(PAST(2*NRDS+I)+(2.D0*THETA-C2M1-C1M1)
-     &     *PAST(3*NRDS+I)) 
+     &     +THETA*(PAST(2*NRDS+I)+(2.D0*THETA-C2M1-C1M1)*PAST(3*NRDS+I)) 
       DLAGR5=DLAGR5/H 
       RETURN 
       END 
@@ -2946,38 +2820,32 @@
         REAL(kind=DP), dimension(1) :: UCONT 
         REAL(kind=DP), dimension(1), intent(inout) :: GRID 
         REAL(kind=DP), dimension(1) :: BPV 
-        INTEGER, dimension(NRDS) :: IPAR 
+        INTEGER, dimension(1) :: IPAR 
         REAL(kind=DP), dimension(1) :: RPAR 
         EXTERNAL PHI
         LOGICAL FIRST,LAST,BPD,FLAGS,FLAGN 
 C----   COMMON BLOCKS 
         COMMON /CONSTN/C1,C2,C1M1,C2M1,C1MC2 
-      COMMON /POSITS/X0B,UROUND,HMAX,IACT,IRTRN,IDIF,MXST,FLAGS,FLAGN 
-        
-        INTEGER LRPAST = MXST*IDIF
+        COMMON /POSITS/X0B,UROUND,HMAX,IACT,IRTRN,IDIF,MXST,FLAGS,FLAGN 
 C 
-C ---   
-C        WRITE(6,*) 'In BPDTCT, ILBP = ', ILBP
+C ---     
         IF (FIRST) RETURN
         BPD=.FALSE.  
         LRC=4*N 
         EPSILON=1.D-10
         ALLOCATE(YADV(N)) 
         COMPAR=UROUND*MAX(ABS(X),ABS(X+H)) 
-C        WRITE(6,*) 'COMPAR:', COMPAR, X, X+H, UROUND
         
-      XLAST=UCONT(LRC+1) 
+	XLAST=UCONT(LRC+1) 
         HLAST=UCONT(LRC+2) 
         DO IL=1,NLAGS 
-         ALS = ARGLAG(IL,X,Y,RPAR,IPAR,PHI,PAST,IPAST,NRDS,
-     &  LRPAST,N)  
+         ALS = ARGLAG(IL,X,Y,RPAR,IPAR,PHI,PAST,IPAST,NRDS) 
 C -----  DEVIATING ARGUMENT AT X 
 C -----  EXTRAPOLATION OF THE COLLOCATION POLYNOMIAL       
          DO IC=1,N 
           YADV(IC)=CONTR5(IC,N,X+H,UCONT,XLAST,HLAST) 
          END DO 
-         ALD = ARGLAG(IL,X+H,YADV,RPAR,IPAR,PHI,PAST,IPAST,NRDS,
-     &  LRPAST,N) 
+         ALD = ARGLAG(IL,X+H,YADV,RPAR,IPAR,PHI,PAST,IPAST,NRDS) 
 C -----  DEVIATING ARGUMENT AT X+H        
  
          IF (ABS(ALS-ALD).LE.COMPAR) GO TO 33
@@ -3013,10 +2881,8 @@
             XA=X+THNEW*H 
             DO IC=1,N 
              YADV(IC)=CONTR5(IC,N,XA,UCONT,XLAST,HLAST) 
-            END DO
-C            WRITE(6,*) 'Calling arglag (5)' 
-            ALN = ARGLAG(IL,XA,YADV,RPAR,IPAR,PHI,PAST,IPAST,NRDS,
-     &  LRPAST,N)  
+            END DO 
+            ALN = ARGLAG(IL,XA,YADV,RPAR,IPAR,PHI,PAST,IPAST,NRDS) 
             IF ((ALS-BPP)*(ALN-BPP).LE.0.D0) THEN 
              ALD=ALN 
              THRIGH=THNEW 
@@ -3052,7 +2918,7 @@
  37     CONTINUE 
  
         DEALLOCATE(YADV) 
-C        WRITE(6,*) 'End of BPDTCT, ILBP = ', ILBP
+
         RETURN 
         END 
  
@@ -3064,23 +2930,20 @@
 C     THIS SUBROUTINE CAN BE USED FOR APPROXIMATING BREAKING POINTS  
 C     IN TANDEM WITH THE SIMPLIFIED NEWTON ITERATION.. 
 C ---------------------------------------------------------- 
-      IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
-      INTEGER, PARAMETER :: DP=kind(1D0) 
-      REAL(kind=DP), dimension(N) :: Y,Z1,Z2,Z3 
-      REAL(kind=DP), dimension(1), intent(in) :: PAST
-      INTEGER, dimension(NRDS), intent(in) :: IPAST
-      REAL(kind=DP), dimension(:), allocatable :: YCONT,YAPP
-      REAL(kind=DP), dimension(1) :: BPV 
-      INTEGER, dimension(1) :: IPAR 
-      REAL(kind=DP), dimension(1) :: RPAR 
-      EXTERNAL PHI
-      LOGICAL FIRST
-      LOGICAL FLAGS,FLAGN
-C---- COMMON BLOCKS 
-      COMMON /CONSTN/C1,C2,C1M1,C2M1,C1MC2 
-      COMMON /POSITS/X0B,UROUND,HMAX,IACT,IRTRN,IDIF,MXST,FLAGS,FLAGN 
-        
-      INTEGER LRPAST = MXST*IDIF
+        IMPLICIT DOUBLE PRECISION (A-H,O-Z) 
+        INTEGER, PARAMETER :: DP=kind(1D0) 
+        REAL(kind=DP), dimension(N) :: Y,Z1,Z2,Z3 
+        REAL(kind=DP), dimension(1), intent(in) :: PAST
+        INTEGER, dimension(1), intent(in) :: IPAST
+        REAL(kind=DP), dimension(:), allocatable :: YCONT,YAPP
+        REAL(kind=DP), dimension(1) :: BPV 
+        INTEGER, dimension(1) :: IPAR 
+        REAL(kind=DP), dimension(1) :: RPAR 
+        EXTERNAL PHI
+        LOGICAL FIRST 
+C----   COMMON BLOCKS 
+        COMMON /CONSTN/C1,C2,C1M1,C2M1,C1MC2 
+        COMMON /POSITS/X0B,UROUND,HMAX,IACT,IRTRN,IDIF,MXST,FLAGS,FLAGN 
 C 
 C ---     
         ALLOCATE(YCONT(4*N),YAPP(N))
@@ -3114,15 +2977,11 @@
         XL=X+THLEFT*H
         DO I=1,N 
             YAPP(I)=CONTR5(I,N,XL,YCONT,XSOL,HSOL) 
-        END DO
-C        WRITE(6,*) 'Calling arglag (6)' 
-        ALS = ARGLAG(ILBP,XL,YAPP,RPAR,IPAR,PHI,PAST,IPAST,NRDS,
-     &  LRPAST,N) 
+        END DO 
+        ALS = ARGLAG(ILBP,XL,YAPP,RPAR,IPAR,PHI,PAST,IPAST,NRDS)
 C ---
         XR=X+THRIGH*H
-C        WRITE(6,*) 'Calling arglag (7)'
-        ALD = ARGLAG(ILBP,XR,YCONT,RPAR,IPAR,PHI,PAST,IPAST,NRDS,
-     &  LRPAST,N) 
+        ALD = ARGLAG(ILBP,XR,YCONT,RPAR,IPAR,PHI,PAST,IPAST,NRDS)
         DO K=1,KMAX 
             THNEW = THRIGH - (ALD-BPP)*(THRIGH-THLEFT)/(ALD-ALS)  
             THLEFT= THRIGH
@@ -3137,10 +2996,8 @@
             ALS=ALD
             DO I=1,N 
              YAPP(I)=CONTR5(I,N,XAP,YCONT,XSOL,HSOL) 
-            END DO
-C            WRITE(6,*) 'Calling arglag (8)' 
-            ALD = ARGLAG(ILBP,XAP,YAPP,RPAR,IPAR,PHI,PAST,IPAST,NRDS,
-     &  LRPAST,N)  
+            END DO 
+            ALD = ARGLAG(ILBP,XAP,YAPP,RPAR,IPAR,PHI,PAST,IPAST,NRDS) 
             IF (ABS(ALD-ALS).LE.EPSILON) GOTO 36 
         END DO 
 
